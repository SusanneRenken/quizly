from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase
from django.contrib.auth.models import User
from unittest.mock import patch
from management_app.services.error import AIPipelineError
from management_app.models import Quiz


def _make_valid_payload():
    return {
        "title": "Stub Quiz",
        "description": "Generated by stub",
        "questions": [
            {
                "question_title": f"Q{i}",
                "question_options": [f"A{i}", f"B{i}", f"C{i}", f"D{i}"],
                "answer": f"A{i}",
            }
            for i in range(1, 11)
        ],
    }


class CreateQuizStubTests(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="tester", password="secret123")
        self.client.force_authenticate(user=self.user)
        self.url = reverse("create-quiz")
        self.valid_url = {"url": "https://www.youtube.com/watch?v=abcdefghijk"}

    def test_create_quiz_valid_url_happy_path(self):
        res = self.client.post(self.url, self.valid_url, format="json")
        self.assertEqual(res.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Quiz.objects.count(), 1)
        quiz = Quiz.objects.first()
        self.assertEqual(quiz.questions.count(), 10)
        self.assertIn("questions", res.data)
        self.assertEqual(len(res.data["questions"]), 10)

    @patch("management_app.api.serializers.build_quiz_stub", side_effect=AIPipelineError("boom"))
    def test_pipeline_failure_returns_502_and_no_db_write(self, _mock):
        res = self.client.post(self.url, self.valid_url, format="json")
        self.assertEqual(res.status_code, status.HTTP_502_BAD_GATEWAY)
        self.assertEqual(Quiz.objects.count(), 0)

    @patch("management_app.api.serializers.build_quiz_stub")
    def test_invalid_payload_structure_returns_502_no_db_write(self, mock_build):
        bad = _make_valid_payload()
        bad["questions"][3]["question_options"] = ["A", "B", "C"]  # 3 statt 4 Optionen
        mock_build.return_value = bad
        res = self.client.post(self.url, self.valid_url, format="json")
        self.assertEqual(res.status_code, status.HTTP_502_BAD_GATEWAY)
        self.assertEqual(Quiz.objects.count(), 0)

    @patch("management_app.services.persist_quiz.Question.objects.bulk_create", side_effect=Exception("db fail"))
    @patch("management_app.api.serializers.build_quiz_stub", return_value=_make_valid_payload())
    def test_atomic_rollback_on_db_error(self, _mock_build, _mock_bulk):
        with self.assertRaises(Exception):
            self.client.post(self.url, self.valid_url, format="json")
        self.assertEqual(Quiz.objects.count(), 0)
